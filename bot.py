import discord  # Importation de la biblioth√®que Discord
import os  # Importation du module OS pour interagir avec le syst√®me d'exploitation
import json  # Importation du module JSON pour g√©rer les fichiers JSON
from discord.ext import commands  # Importation des commandes d'extension Discord
from discord import app_commands  # Importation des commandes d'application Discord
from dotenv import load_dotenv  # Importation de dotenv pour charger les variables d'environnement

load_dotenv()  # Chargement des variables d'environnement depuis un fichier .env
AUTHORIZED_CHANNEL_ID = int(os.getenv("SALON_TOKEN"))  # Convertit en entier

# Fichier JSON pour stocker les r√¥les interdits
data_file = "roles_to_remove.json"

# Fonction pour charger les donn√©es √† partir du fichier JSON
def load_data():
    if not os.path.exists(data_file):  # V√©rifie si le fichier JSON existe
        return {}  # Retourne un dictionnaire vide si le fichier n'existe pas
    with open(data_file, "r", encoding="utf-8") as file:  # Ouvre le fichier en mode lecture
        return json.load(file)  # Charge et retourne les donn√©es JSON

# Fonction pour sauvegarder les donn√©es dans le fichier JSON
def save_data(data):
    with open(data_file, "w", encoding="utf-8") as file:  # Ouvre le fichier en mode √©criture
        json.dump(data, file, indent=4)  # √âcrit les donn√©es JSON dans le fichier avec une indentation

# Charger les r√¥les interdits dans une variable globale
roles_to_remove = load_data()

intents = discord.Intents.default()  # Active les intentions par d√©faut du bot
intents.members = True  # Active la d√©tection des mises √† jour des membres
bot = commands.Bot(command_prefix="!", intents=intents)  # Cr√©ation du bot avec un pr√©fixe "!"

async def check_channel(interaction: discord.Interaction):
    server_id = str(interaction.guild.id)
    authorized_channel_id = roles_to_remove.get(server_id, {}).get("authorized_channel")
    
    if not authorized_channel_id or interaction.channel.id != int(authorized_channel_id):
        await interaction.response.send_message("‚ùå Cette commande ne peut √™tre utilis√©e que dans le salon autoris√©.")
        return False
    return True

@bot.event
async def on_ready():  # √âv√©nement d√©clench√© lorsque le bot est pr√™t
    print(f"‚úÖ Bot connect√© en tant que {bot.user}")  # Affiche un message dans la console
    try:
        await bot.tree.sync()  # Synchronise les commandes slash du bot
        print("‚úÖ Commandes synchronis√©es")  # Affiche un message de confirmation
    except Exception as e:
        print(f"‚ùå Erreur de synchronisation : {e}")  # Affiche une erreur en cas d'√©chec

# Classe pour cr√©er un menu de s√©lection de r√¥les
class RoleSelect(discord.ui.Select):
    def __init__(self, member: discord.Member):  # Initialisation avec un membre
        roles = [
            role for role in member.roles  # Liste des r√¥les du membre
            if role != member.guild.default_role and role < member.guild.me.top_role  # Exclut le r√¥le par d√©faut et les r√¥les sup√©rieurs √† celui du bot
        ]
        options = [
            discord.SelectOption(label=role.name, value=str(role.id)) for role in roles  # Cr√©e une option pour chaque r√¥le du membre
        ]
        if not options:  # V√©rifie s'il n'y a aucun r√¥le s√©lectionnable
            options = [discord.SelectOption(label="Aucun r√¥le disponible", value="none", default=True, description="Aucun r√¥le supprimable")]

        super().__init__(placeholder="S√©lectionnez les r√¥les √† retirer", min_values=1, max_values=len(options), options=options)  # D√©finit les param√®tres du menu d√©roulant
        self.member = member  # Stocke le membre

    async def callback(self, interaction: discord.Interaction):  # Fonction ex√©cut√©e lorsque l'utilisateur fait une s√©lection
        if "none" in self.values:  # V√©rifie si l'utilisateur a s√©lectionn√© "Aucun r√¥le disponible"
            await interaction.response.send_message("Aucun r√¥le √† retirer.", ephemeral=True)  # Envoie un message temporaire
            return
        
        removed_roles = []  # Liste des r√¥les supprim√©s
        for role_id in self.values:  # Parcourt les r√¥les s√©lectionn√©s
            role = discord.utils.get(self.member.guild.roles, id=int(role_id))  # R√©cup√®re l'objet r√¥le
            if role in self.member.roles:  # V√©rifie si le membre poss√®de le r√¥le
                await self.member.remove_roles(role)  # Retire le r√¥le du membre
                removed_roles.append(role.name)  # Ajoute le r√¥le √† la liste des r√¥les supprim√©s

                # üìå Enregistrer le r√¥le comme interdit
                user_id = str(self.member.id)
                if user_id not in roles_to_remove:
                    roles_to_remove[user_id] = []
                if role_id not in roles_to_remove[user_id]:
                    roles_to_remove[user_id].append(role_id)  # Ajoute le r√¥le √† la liste des r√¥les interdits
                save_data(roles_to_remove)  # Sauvegarde les r√¥les interdits

        if removed_roles:  # V√©rifie si des r√¥les ont √©t√© supprim√©s
            await interaction.response.send_message(
                f"üî¥ R√¥les supprim√©s : {', '.join(removed_roles)} pour {self.member.mention}."#, ephemeral=True)  # Envoie un message de confirmation
            )
        else:
            await interaction.response.send_message("Aucun r√¥le n'a √©t√© retir√©.")#, ephemeral=True)  # Envoie un message si aucun r√¥le n'a √©t√© supprim√©

class RoleSelectView(discord.ui.View):
    def __init__(self, member: discord.Member):
        super().__init__()
        self.add_item(RoleSelect(member))  # Ajoute l'√©l√©ment RoleSelect √† la vue
        
@bot.tree.command(name="choosechannel", description="D√©finit le salon autoris√© pour les commandes du bot.")
@app_commands.checks.has_permissions(administrator=True)
async def choosechannel(interaction: discord.Interaction, channel: discord.TextChannel):
    server_id = str(interaction.guild.id)
    
    if server_id not in roles_to_remove:
        roles_to_remove[server_id] = {"authorized_channel": str(channel.id), "banned_roles": {}}
    else:
        roles_to_remove[server_id]["authorized_channel"] = str(channel.id)
    
    save_data(roles_to_remove)
    await interaction.response.send_message(f"‚úÖ Le salon autoris√© a √©t√© d√©fini sur {channel.mention}.")

@choosechannel.error
async def choosechannel_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.errors.MissingPermissions):
        await interaction.response.send_message("‚ùå Vous devez √™tre administrateur pour utiliser cette commande.")#, ephemeral=True)

# Bannir un r√¥le pour un membre du serveur
@bot.tree.command(name="roleban", description="Bannit un r√¥le pour un membre du serveur.")
@app_commands.describe(member="Membre du serveur", role="R√¥le √† bannir")
async def roleban(interaction: discord.Interaction, member: discord.Member, role: discord.Role):
    if not await check_channel(interaction):
        return
    
    server_id = str(interaction.guild.id)
    user_id = str(member.id)
    role_id = str(role.id)
    
    if server_id not in roles_to_remove:
        roles_to_remove[server_id] = {"authorized_channel": "", "banned_roles": {}}
    if user_id not in roles_to_remove[server_id]["banned_roles"]:
        roles_to_remove[server_id]["banned_roles"][user_id] = []
    if role_id not in roles_to_remove[server_id]["banned_roles"][user_id]:
        roles_to_remove[server_id]["banned_roles"][user_id].append(role_id)
    
    save_data(roles_to_remove)
    await interaction.response.send_message(f"üî¥ Le r√¥le {role.name} a √©t√© interdit pour {member.mention}.")

# D√©bannir un r√¥le d'un membre
@bot.tree.command(name="roledeban", description="Supprime un r√¥le banni d'un membre.")
@app_commands.describe(member="Membre du serveur", role="R√¥le √† d√©bannir")
async def roledeban(interaction: discord.Interaction, member: discord.Member, role: discord.Role):
    if not await check_channel(interaction):
        return
    
    server_id = str(interaction.guild.id)
    user_id = str(member.id)
    role_id = str(role.id)
    
    if server_id in roles_to_remove and user_id in roles_to_remove[server_id]["banned_roles"]:
        if role_id in roles_to_remove[server_id]["banned_roles"][user_id]:
            roles_to_remove[server_id]["banned_roles"][user_id].remove(role_id)
            if not roles_to_remove[server_id]["banned_roles"][user_id]:
                del roles_to_remove[server_id]["banned_roles"][user_id]
            save_data(roles_to_remove)
            await interaction.response.send_message(f"‚úÖ Le r√¥le {role.name} a √©t√© d√©banni pour {member.mention}.")
            return
    
    await interaction.response.send_message(f"‚ùå {member.mention} n'a pas ce r√¥le en tant que r√¥le interdit.")


@bot.event
async def on_member_update(before: discord.Member, after: discord.Member):
    server_id = str(after.guild.id)
    user_id = str(after.id)

    if server_id not in roles_to_remove:
        return

    removed_roles = []

    # V√©rifier les r√¥les interdits sp√©cifiques √† l'utilisateur
    if "banned_roles" in roles_to_remove[server_id]:
        if user_id in roles_to_remove[server_id]["banned_roles"]:
            for role_id in roles_to_remove[server_id]["banned_roles"][user_id]:
                role = discord.utils.get(after.guild.roles, id=int(role_id))
                if role and role in after.roles and role not in before.roles:
                    await after.remove_roles(role)
                    removed_roles.append(role.name)

    # V√©rifier les r√¥les interdits globalement pour tous les nouveaux membres
    if "global_banned_roles" in roles_to_remove[server_id]:
        for role_id in roles_to_remove[server_id]["global_banned_roles"]:
            role = discord.utils.get(after.guild.roles, id=int(role_id))
            if role and role in after.roles and role not in before.roles:
                await after.remove_roles(role)
                removed_roles.append(role.name)

    if removed_roles:
        print(f"üî¥ {after.name} a re√ßu des r√¥les interdits : {', '.join(removed_roles)} (supprim√©s)")
        try:
            await after.send(f"üö® Attention {after.mention}, les r√¥les suivants sont interdits sur ce serveur et ont √©t√© retir√©s automatiquement : {', '.join(removed_roles)}.")
        except:
            print(f"Impossible d'envoyer un MP √† {after.name}.")


bot.run(os.getenv('DISCORD_TOKEN'))  # D√©marre le bot avec le token stock√© dans les variables d'environnement
